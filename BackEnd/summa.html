<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Boy & Girl — Three.js → GIF</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#111; color:#eee; }
    #container { width: 100vw; height: 85vh; display: block; }
    #ui { padding: 12px; display:flex; gap:8px; align-items:center; justify-content:center; }
    button { padding:8px 12px; border-radius:8px; border: none; background:#3b82f6; color:white; cursor:pointer; }
    button:disabled{ opacity:0.5; cursor:default; }
    #status { font-size:0.9rem; color:#ddd; }
    a.download { color:#34d399; text-decoration:none; font-weight:600; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="ui">
    <button id="recordBtn">Record GIF (2s)</button>
    <button id="previewBtn">Preview (toggle)</button>
    <div id="status">Ready</div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <!-- gif.js (encoder) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script>
  // Basic scene setup
  const container = document.getElementById('container');
  const renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 3, 8);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;

  // Lights
  const hemi = new THREE.HemisphereLight(0xddeeff, 0x20252a, 0.7);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(5, 10, 2);
  scene.add(dir);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(40,40),
    new THREE.MeshStandardMaterial({color:0x091018, roughness:0.9})
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  scene.add(ground);

  // Utility: create a simple stylized character using primitive meshes (head, body, arms, legs)
  function createCharacter({skin=0xffe0bd, clothes=0x3b82f6, hair=0x222222, isGirl=false}) {
    const root = new THREE.Group();

    // torso
    const torsoGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.6, 16);
    const torsoMat = new THREE.MeshStandardMaterial({color:clothes, metalness:0.05, roughness:0.7});
    const torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 1.1;
    root.add(torso);

    // head
    const headGeo = new THREE.SphereGeometry(0.45, 24, 24);
    const headMat = new THREE.MeshStandardMaterial({color:skin});
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 2.2;
    root.add(head);

    // hair (simple cap)
    const hairGeo = new THREE.SphereGeometry(0.47, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.6);
    const hairMat = new THREE.MeshStandardMaterial({color:hair});
    const hairMesh = new THREE.Mesh(hairGeo, hairMat);
    hairMesh.position.y = 2.28;
    hairMesh.rotation.x = Math.PI;
    root.add(hairMesh);

    // eyes (simple dots)
    const eyeGeo = new THREE.SphereGeometry(0.045, 8, 6);
    const eyeMat = new THREE.MeshStandardMaterial({color:0x050505});
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    const rightEye = leftEye.clone();
    leftEye.position.set(-0.15, 2.25, 0.42);
    rightEye.position.set(0.15, 2.25, 0.42);
    root.add(leftEye, rightEye);

    // arms
    const armGeo = new THREE.CylinderGeometry(0.11, 0.13, 1.0, 12);
    const armMat = new THREE.MeshStandardMaterial({color:skin});
    const leftArm = new THREE.Mesh(armGeo, armMat);
    const rightArm = leftArm.clone();
    leftArm.position.set(-0.75, 1.3, 0);
    rightArm.position.set(0.75, 1.3, 0);
    leftArm.rotation.z = Math.PI/8;
    rightArm.rotation.z = -Math.PI/8;

    // attach small sleeve pieces to look like cloth
    const sleeveGeo = new THREE.CylinderGeometry(0.14,0.14,0.3,12);
    const sleeveMat = new THREE.MeshStandardMaterial({color:clothes});
    const leftSleeve = new THREE.Mesh(sleeveGeo, sleeveMat);
    const rightSleeve = leftSleeve.clone();
    leftSleeve.position.set(0, -0.35, 0);
    rightSleeve.position.set(0, -0.35, 0);
    leftArm.add(leftSleeve);
    rightArm.add(rightSleeve);

    // group arms for animation
    const leftArmGroup = new THREE.Group(); leftArmGroup.add(leftArm);
    const rightArmGroup = new THREE.Group(); rightArmGroup.add(rightArm);
    leftArmGroup.position.y = 1.7; leftArmGroup.position.x = -0.75;
    rightArmGroup.position.y = 1.7; rightArmGroup.position.x = 0.75;
    root.add(leftArmGroup, rightArmGroup);

    // legs
    const legGeo = new THREE.CylinderGeometry(0.16, 0.18, 1.1, 12);
    const legMat = new THREE.MeshStandardMaterial({color:0x222222});
    const leftLeg = new THREE.Mesh(legGeo, legMat);
    const rightLeg = leftLeg.clone();
    leftLeg.position.set(-0.28, 0.05, 0);
    rightLeg.position.set(0.28, 0.05, 0);
    root.add(leftLeg, rightLeg);

    // small skirt if isGirl (stylized)
    if (isGirl) {
      const skirtGeo = new THREE.ConeGeometry(0.8, 0.6, 20);
      const skirtMat = new THREE.MeshStandardMaterial({color:0xff6bcb, roughness:0.7});
      const skirt = new THREE.Mesh(skirtGeo, skirtMat);
      skirt.position.y = 1.0;
      skirt.rotation.x = Math.PI;
      root.add(skirt);
    }

    // simple name label (optional)
    return { root, head, leftArmGroup, rightArmGroup };
  }

  // Create boy and girl
  const boy = createCharacter({skin:0xffd3b6, clothes:0x3b82f6, hair:0x1f2937, isGirl:false});
  const girl = createCharacter({skin:0xffe0bd, clothes:0xff6bcb, hair:0x4b5563, isGirl:true});

  // Position them
  boy.root.position.x = -1.6;
  girl.root.position.x = 1.6;
  scene.add(boy.root, girl.root);

  // small decorative balloons or heart between them
  const heartGeom = new THREE.SphereGeometry(0.2, 12, 12);
  const heartMat = new THREE.MeshStandardMaterial({color:0xff6b6b});
  const heart = new THREE.Mesh(heartGeom, heartMat);
  heart.position.set(0,2.2,0.6);
  scene.add(heart);

  // animation state
  let clock = new THREE.Clock();
  let mixerTime = 0;

  // preview auto-rotate toggle
  let animPreview = true;
  document.getElementById('previewBtn').addEventListener('click', () => {
    animPreview = !animPreview;
    document.getElementById('status').textContent = animPreview ? 'Preview: ON' : 'Preview: OFF';
  });

  // Render loop
  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    mixerTime = t;

    // small walk/bounce
    const bob = Math.sin(t * 2) * 0.04;
    boy.root.position.y = 0 + bob;
    girl.root.position.y = 0 - bob;

    // arms waving
    boy.leftArmGroup.rotation.z = Math.sin(t*3) * 0.9 - 0.4;
    boy.rightArmGroup.rotation.z = Math.cos(t*3) * 0.25 - 0.2;
    girl.leftArmGroup.rotation.z = Math.cos(t*3 + 0.5) * 0.6 - 0.3;
    girl.rightArmGroup.rotation.z = Math.sin(t*3 + 0.8) * 0.8 - 0.2;

    // heart bounce and rotate
    heart.scale.setScalar(1 + Math.sin(t * 3) * 0.08);
    heart.rotation.y = t * 0.8;

    if (animPreview) {
      // camera slight orbit
      camera.position.x = Math.sin(t*0.35) * 8 * 0.2 + 0; // subtle movement
      camera.position.z = 8 + Math.cos(t*0.15) * 0.4;
      camera.lookAt(0,1.4,0);
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Handle resizing
  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  });

  // GIF recording logic
  const recordBtn = document.getElementById('recordBtn');
  const status = document.getElementById('status');

  function recordGif(durationSeconds = 2, fps = 30) {
    recordBtn.disabled = true;
    status.textContent = 'Recording GIF...';
    // configure gif.js
    const gif = new GIF({
      workers: 2,
      quality: 10,
      workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js',
      width: renderer.domElement.width,
      height: renderer.domElement.height
    });

    const totalFrames = Math.max(1, Math.floor(durationSeconds * fps));
    let framesCaptured = 0;

    // We will capture frames at requestAnimationFrame pace but control timing
    const startTime = performance.now();
    let lastFrameTime = startTime;
    const frameInterval = 1000 / fps;

    function captureLoop(now) {
      const elapsed = now - startTime;
      if (elapsed >= durationSeconds * 1000 || framesCaptured >= totalFrames) {
        // finish
        gif.on('finished', function(blob) {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'three-character.gif';
          link.className = 'download';
          link.textContent = 'Download GIF';
          status.innerHTML = '';
          status.appendChild(link);
          recordBtn.disabled = false;
        });
        gif.render();
        return;
      }
      if (now - lastFrameTime >= frameInterval) {
        // render one frame (renderer already animating) and add to gif
        try {
          gif.addFrame(renderer.domElement, {copy:true, delay: frameInterval});
        } catch (e) {
          console.warn('Frame capture failed:', e);
        }
        framesCaptured++;
        lastFrameTime = now;
      }
      requestAnimationFrame(captureLoop);
    }

    // small warm-up for consistent frames (one animation tick)
    requestAnimationFrame(captureLoop);
  }

  recordBtn.addEventListener('click', () => {
    // record 2 seconds by default at 30fps -> ~60 frames
    recordGif(2, 30);
  });

  // initial status
  status.textContent = 'Ready — press "Record GIF" to capture a short animation.';
  </script>
</body>
</html>
